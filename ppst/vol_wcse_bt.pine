// PPST Volume Filter Backtest Strategy
// Based on PP SuperTrend by LonesomeTheBlue
// Tests volume filter + quiet hours effectiveness via TV Strategy Tester

//@version=5
strategy(title="Vol+WCSE Filter BT", shorttitle="5M-VOL-WCSE", overlay=true,
         default_qty_type=strategy.fixed, default_qty_value=10000,
         initial_capital=10000, currency=currency.USD,
         pyramiding=0, process_orders_on_close=true,
         max_bars_back=5000, max_labels_count=500)

// ═══════════════════════════════════════════════════════════════════════════════
// PP SUPERTREND SETTINGS
// ═══════════════════════════════════════════════════════════════════════════════
ind_group = "PP SuperTrend"
prd = input.int(defval = 2, title="Pivot Point Period", minval = 1, maxval = 50, group=ind_group, display=display.status_line)
Factor = input.float(defval = 5.0, title = "ATR Factor", minval = 0.1, step = 0.1, group=ind_group, display=display.status_line)
Pd = input.int(defval = 10, title = "ATR Period", minval=1, group=ind_group, display=display.status_line)
// Note: status line shows "PPST-VF {prd} {Factor} {Pd} {sma} {vf}" — PineScript doesn't support custom formatting
showpivot = input.bool(defval = false, title="Show Pivot Points", group=ind_group, display=display.none)
showlabel = input.bool(defval = true, title="Show Buy/Sell Labels", group=ind_group, display=display.none)

// ═══════════════════════════════════════════════════════════════════════════════
// VOLUME FILTER
// ═══════════════════════════════════════════════════════════════════════════════
vf_group = "Volume Filter"
use_vol_filter = input.bool(defval = true, title="Enable Volume Filter", group=vf_group, display=display.none)
vol_sma_period = input.int(defval = 20, title="Volume SMA Period", minval = 5, maxval = 200, group=vf_group, display=display.status_line)
vol_threshold = input.float(defval = 1.6, title="Min Volume Ratio (VF)", minval = 0.1, step = 0.1, group=vf_group,
     tooltip="Signal candle volume / SMA(volume, N). 1.0 = only trade when volume >= average", display=display.status_line)
vol_recovery_bars = input.int(defval = 0, title="Vol Recovery Bars", minval = 0, maxval = 20, group=vf_group,
     tooltip="After vol-filtered signal, wait up to N bars for volume to recover. 0 = disabled (no recovery).", display=display.none)
filtered_exit_bars = input.int(defval = 0, title="Filtered Exit Bars", minval = 0, maxval = 10, group=vf_group,
     tooltip="When signal is vol-filtered with opposite position open: 0 = keep until SL hit (frozen SL), 1-10 = close after N bars.", display=display.none)
show_vol_filter = input.bool(defval = true, title="Show Vol Filtered Signals", group=vf_group, display=display.none)

// ═══════════════════════════════════════════════════════════════════════════════
// QUIET HOURS FILTER
// ═══════════════════════════════════════════════════════════════════════════════
qh_group = "Quiet Hours"
use_quiet = input.bool(defval = true, title="Enable Quiet Hours", group=qh_group, display=display.none)
quiet_start_hour = input.int(defval = 12, title="Start Hour", minval = 0, maxval = 23, group=qh_group, display=display.none)
quiet_start_min = input.int(defval = 0, title="Start Minute", minval = 0, maxval = 59, group=qh_group, display=display.none)
quiet_end_hour = input.int(defval = 14, title="End Hour", minval = 0, maxval = 23, group=qh_group, display=display.none)
quiet_end_min = input.int(defval = 30, title="End Minute", minval = 0, maxval = 59, group=qh_group, display=display.none)
quiet_tz = input.string(defval = "America/Los_Angeles", title="Timezone", group=qh_group,
     options=["America/Los_Angeles", "America/New_York", "America/Chicago", "Europe/London", "UTC"], display=display.none)

// ═══════════════════════════════════════════════════════════════════════════════
// STRATEGY SETTINGS
// ═══════════════════════════════════════════════════════════════════════════════
strat_group = "Strategy"
i_sizing_mode = input.string("Compound Risk %", "Sizing Mode", options=["Compound Risk %", "Fixed Units"], group=strat_group, display=display.none)
i_risk_percent = input.float(1.0, "Risk Per Trade (%)", group=strat_group, minval=0.1, step=0.1, display=display.none)
i_units = input.int(10000, "Fixed Position Size (Units)", group=strat_group, minval=1000, step=1000, display=display.none)
i_max_position = input.int(500000, "Max Position Size (Units)", group=strat_group, minval=1000, step=50000,
     tooltip="Safety cap. 500K ≈ $10K equity at 50:1 OANDA leverage", display=display.none)
i_enable_signal = input.bool(true, "Enable Signal Entries", group=strat_group,
     tooltip="Trend-change entries. Disable to test WCSE-only or Vol-only scenarios", display=display.none)
i_spread_pips = input.float(1.5, "Spread (Pips)", group=strat_group, minval=0, step=0.1, display=display.none)
i_sl_buffer = input.float(0.0, "SL Buffer (Pips)", group=strat_group, minval=0, step=0.5,
     tooltip="Added below SuperTrend for LONG SL, above for SHORT SL", display=display.none)
i_tp_type = input.string("Risk Ratio", "TP Type", options=["Risk Ratio", "Fixed Pips", "None"], group=strat_group, display=display.none)
i_tp_ratio = input.float(2.0, "TP Risk:Reward Ratio", group=strat_group, minval=0.5, step=0.1, display=display.none)
i_tp_pips = input.float(30.0, "TP Fixed Pips", group=strat_group, minval=5, step=1, display=display.none)

// ═══════════════════════════════════════════════════════════════════════════════
// WCSE (WICK CROSS SUPERTREND ENTRY)
// ═══════════════════════════════════════════════════════════════════════════════
wcse_group = "WCSE (Wick Cross ST Entry)"
i_wcse_enabled = input.bool(true, "Enable WCSE", group=wcse_group, display=display.none)
i_wcse_entry_times = input.int(1, "Max TP Exits Per Swing", minval=0, group=wcse_group,
     tooltip="0=unlimited. Only TP exits count; SL exits are free retries", display=display.none)
i_wcse_c1_body = input.float(0.1, "C1 Min Body (pips)", group=wcse_group, minval=0, step=0.1, display=display.none)
i_wcse_c1_close = input.float(0.8, "C1 Close Proximity (pips)", group=wcse_group, minval=0, step=0.5, display=display.none)
i_wcse_c2_body = input.float(0.6, "C2 Min Body (pips)", group=wcse_group, minval=0, step=0.1, display=display.none)
i_wcse_wick_cross = input.float(0.4, "Wick Cross Min (pips)", group=wcse_group, minval=0, step=0.5,
     tooltip="Min wick depth through SuperTrend for Pattern C (wick cross)", display=display.none)
i_wcse_tp_rr = input.float(1.2, "TP Risk:Reward", group=wcse_group, minval=0.5, step=0.5, display=display.none)
i_wcse_sl_buffer = input.float(0.0, "SL Buffer (pips)", group=wcse_group, minval=0, step=0.5, display=display.none)
i_wcse_wx_sl_buffer = input.float(0.0, "WX SL Buffer (pips)", group=wcse_group, minval=0, step=0.5,
     tooltip="Wick Cross SL = SuperTrend ± this buffer", display=display.none)
i_wcse_wx_trail_after = input.int(3, "WX Trail After (bars)", group=wcse_group, minval=0, maxval=20,
     tooltip="Start trailing SL with SuperTrend after N bars. 0 = trail immediately", display=display.none)
i_wcse_wx_trail_buffer = input.float(0.0, "WX Trail Buffer (pips)", group=wcse_group, minval=0, step=0.5,
     tooltip="Buffer from SuperTrend when WX trailing is active", display=display.none)

// Display
disp_group = "Display"
show_stats = input.bool(defval = false, title="Show Statistics Table", group=disp_group, display=display.none)
plot_sl_tp = input.bool(defval = false, title="Show SL/TP Levels", group=disp_group, display=display.none)

// ═══════════════════════════════════════════════════════════════════════════════
// HELPER FUNCTIONS
// ═══════════════════════════════════════════════════════════════════════════════
pip_value() =>
    syminfo.mintick * (syminfo.type == "forex" ? 10 : 1)

pips_to_price(pips) =>
    pips * pip_value()

// ═══════════════════════════════════════════════════════════════════════════════
// PP SUPERTREND CALCULATION
// ═══════════════════════════════════════════════════════════════════════════════
float ph = ta.pivothigh(prd, prd)
float pl = ta.pivotlow(prd, prd)

plotshape(ph and showpivot, text="H", style=shape.labeldown, color=color.new(color.white, 100), textcolor=color.red, location=location.abovebar, offset=-prd, display=display.pane)
plotshape(pl and showpivot, text="L", style=shape.labeldown, color=color.new(color.white, 100), textcolor=color.lime, location=location.belowbar, offset=-prd, display=display.pane)

var float center = na
float lastpp = ph ? ph : pl ? pl : na
if lastpp
    if na(center)
        center := lastpp
    else
        center := (center * 2 + lastpp) / 3

Up = center - (Factor * ta.atr(Pd))
Dn = center + (Factor * ta.atr(Pd))

float TUp = na
float TDown = na
Trend = 0
TUp := close[1] > TUp[1] ? math.max(Up, TUp[1]) : Up
TDown := close[1] < TDown[1] ? math.min(Dn, TDown[1]) : Dn
Trend := close > TDown[1] ? 1 : close < TUp[1] ? -1 : nz(Trend[1], 1)
Trailingsl = Trend == 1 ? TUp : TDown

// Plot SuperTrend line
linecolor = Trend == 1 and nz(Trend[1]) == 1 ? color.lime : Trend == -1 and nz(Trend[1]) == -1 ? color.red : na
plot(Trailingsl, color=linecolor, linewidth=2, title="PP SuperTrend", display=display.pane)

// Raw signals (trend change)
bsignal = Trend == 1 and Trend[1] == -1
ssignal = Trend == -1 and Trend[1] == 1

// ── WCSE Pattern A: 2-Candle Engulfing ──
detect_wcse_engulf_long(c1_close_p, c1_body_p, c2_body_p) =>
    c1_red = close[1] < open[1]
    c1_body = open[1] - close[1]
    c1_body_ok = c1_body >= pips_to_price(c1_body_p)
    c1_close_ok = math.abs(close[1] - TUp[1]) <= pips_to_price(c1_close_p)
    c2_green = close > open
    c2_body = close - open
    c2_body_ok = c2_body >= pips_to_price(c2_body_p)
    c2_engulfs = c2_body > c1_body
    c1_red and c1_body_ok and c1_close_ok and c2_green and c2_body_ok and c2_engulfs

detect_wcse_engulf_short(c1_close_p, c1_body_p, c2_body_p) =>
    c1_green = close[1] > open[1]
    c1_body = close[1] - open[1]
    c1_body_ok = c1_body >= pips_to_price(c1_body_p)
    c1_close_ok = math.abs(close[1] - TDown[1]) <= pips_to_price(c1_close_p)
    c2_red = close < open
    c2_body = open - close
    c2_body_ok = c2_body >= pips_to_price(c2_body_p)
    c2_engulfs = c2_body > c1_body
    c1_green and c1_body_ok and c1_close_ok and c2_red and c2_body_ok and c2_engulfs

// ── WCSE Pattern B: 3-Candle Engulfing ──
detect_wcse_engulf_long_3(c1_close_p, c1_body_p, c2_body_p) =>
    c1_red = close[2] < open[2]
    c1_body = open[2] - close[2]
    c1_body_ok = c1_body >= pips_to_price(c1_body_p)
    c1_close_ok = math.abs(close[2] - TUp[2]) <= pips_to_price(c1_close_p)
    c3_green = close > open
    c3_body = close - open
    c3_body_ok = c3_body >= pips_to_price(c2_body_p)
    net_move = close - open[1]
    c1_red and c1_body_ok and c1_close_ok and c3_green and c3_body_ok and net_move > c1_body

detect_wcse_engulf_short_3(c1_close_p, c1_body_p, c2_body_p) =>
    c1_green = close[2] > open[2]
    c1_body = close[2] - open[2]
    c1_body_ok = c1_body >= pips_to_price(c1_body_p)
    c1_close_ok = math.abs(close[2] - TDown[2]) <= pips_to_price(c1_close_p)
    c3_red = close < open
    c3_body = open - close
    c3_body_ok = c3_body >= pips_to_price(c2_body_p)
    net_move = open[1] - close
    c1_green and c1_body_ok and c1_close_ok and c3_red and c3_body_ok and net_move > c1_body

// ── WCSE Pattern C: Wick Cross SuperTrend ──
detect_wcse_wick_cross_long(wick_cross_p) =>
    is_green = close > open
    wick_below = low < TUp
    wick_depth = TUp - low >= pips_to_price(wick_cross_p)
    close_above = close > TUp
    is_green and wick_below and wick_depth and close_above

detect_wcse_wick_cross_short(wick_cross_p) =>
    is_red = close < open
    wick_above = high > TDown
    wick_depth = high - TDown >= pips_to_price(wick_cross_p)
    close_below = close < TDown
    is_red and wick_above and wick_depth and close_below

// ═══════════════════════════════════════════════════════════════════════════════
// VOLUME FILTER CALCULATION
// ═══════════════════════════════════════════════════════════════════════════════
vol_sma = ta.sma(volume, vol_sma_period)
vol_ratio = vol_sma > 0 ? volume / vol_sma : 0.0
is_low_vol = use_vol_filter and vol_ratio < vol_threshold

// Background highlight when volume ratio >= threshold
bgcolor(use_vol_filter and vol_ratio >= vol_threshold ? color.new(color.green, 90) : na, title="High Volume Zone")

// ═══════════════════════════════════════════════════════════════════════════════
// QUIET HOURS CALCULATION
// ═══════════════════════════════════════════════════════════════════════════════
h = hour(time, quiet_tz)
m = minute(time, quiet_tz)
current_minutes = h * 60 + m
quiet_start_minutes = quiet_start_hour * 60 + quiet_start_min
quiet_end_minutes = quiet_end_hour * 60 + quiet_end_min

is_quiet = false
if use_quiet
    if quiet_start_minutes <= quiet_end_minutes
        // Normal range (e.g. 12:00 - 16:30)
        is_quiet := current_minutes >= quiet_start_minutes and current_minutes < quiet_end_minutes
    else
        // Overnight range (e.g. 22:00 - 06:00)
        is_quiet := current_minutes >= quiet_start_minutes or current_minutes < quiet_end_minutes

// ═══════════════════════════════════════════════════════════════════════════════
// FILTER LOGIC
// ═══════════════════════════════════════════════════════════════════════════════
// Filtered = signal exists but blocked by quiet hours OR low volume
// When filtered: hold existing position, do nothing
is_vol_filtered = (bsignal or ssignal) and is_low_vol and not is_quiet
is_qh_filtered = (bsignal or ssignal) and is_quiet
is_filtered = is_quiet or is_low_vol

// ── Volume Recovery (deferred entry) ──
// When signal is vol-filtered, wait up to N bars for volume to recover
var int deferred_dir = 0      // 1=deferred buy, -1=deferred sell, 0=none
var int deferred_age = 0      // bars since signal was deferred

// New vol-filtered signal → start deferral
if bsignal and is_vol_filtered
    deferred_dir := 1
    deferred_age := 0
if ssignal and is_vol_filtered
    deferred_dir := -1
    deferred_age := 0

// Any new raw signal (even filtered) resets opposite deferral
if bsignal and deferred_dir == -1
    deferred_dir := 0
if ssignal and deferred_dir == 1
    deferred_dir := 0

// Age the deferral each bar (only when no new signal this bar)
if deferred_dir != 0 and not bsignal and not ssignal
    deferred_age := deferred_age + 1

// Expire if too old or trend reversed
if deferred_dir == 1 and (Trend != 1 or deferred_age > vol_recovery_bars)
    deferred_dir := 0
if deferred_dir == -1 and (Trend != -1 or deferred_age > vol_recovery_bars)
    deferred_dir := 0

// Volume recovered? Enter the deferred trade (skip if in quiet hours)
vol_recovered = not is_low_vol and not is_quiet
deferred_buy = deferred_dir == 1 and vol_recovered and deferred_age > 0 and vol_recovery_bars > 0
deferred_sell = deferred_dir == -1 and vol_recovered and deferred_age > 0 and vol_recovery_bars > 0

// Clear deferral after execution
if deferred_buy or deferred_sell
    deferred_dir := 0

// ── Filtered Exit (delayed close of opposite position) ──
// When vol-filtered signal occurs with opposite position open, close after N bars
var int filtered_exit_countdown = 0   // bars remaining until forced close
var int filtered_exit_dir = 0         // 1=close SHORT (buy was filtered), -1=close LONG (sell was filtered)

// New vol-filtered signal with opposite position → start countdown
if bsignal and is_vol_filtered and strategy.position_size < 0 and filtered_exit_bars > 0
    filtered_exit_countdown := filtered_exit_bars
    filtered_exit_dir := 1
if ssignal and is_vol_filtered and strategy.position_size > 0 and filtered_exit_bars > 0
    filtered_exit_countdown := filtered_exit_bars
    filtered_exit_dir := -1

// Any actionable signal cancels the countdown (position will reverse normally)
if (bsignal and not is_filtered) or (ssignal and not is_filtered) or deferred_buy or deferred_sell
    filtered_exit_countdown := 0
    filtered_exit_dir := 0

// Count down and close when expired
filtered_exit_now = false
if filtered_exit_countdown > 0
    filtered_exit_countdown := filtered_exit_countdown - 1
    if filtered_exit_countdown == 0
        filtered_exit_now := true

// ── WCSE State ──
var int wcse_armed_dir = 0      // 1=LONG armed, -1=SHORT armed, 0=off
var int wcse_tp_exits = 0       // TP exit count for entry_times gating
var int wcse_entry_source = 0   // 0=signal, 1=wcse (tracks current position source)
var int wcse_armed_count = 0    // stats: total arm events
var int wcse_entry_count = 0    // stats: total WCSE entries
var int wcse_skip_count = 0     // stats: pattern matched but entry skipped (sl_dist <= 0)
var bool wcse_is_wx_entry = false   // current position is from wick cross pattern
var int wcse_wx_entry_bar = 0       // bar_index when WX entry was placed

// ── WCSE Auto-Arm (always armed in current trend direction) ──
if i_wcse_enabled
    if Trend == 1
        if wcse_armed_dir != 1
            wcse_tp_exits := 0
            wcse_armed_count := wcse_armed_count + 1
        wcse_armed_dir := 1
    else if Trend == -1
        if wcse_armed_dir != -1
            wcse_tp_exits := 0
            wcse_armed_count := wcse_armed_count + 1
        wcse_armed_dir := -1
    else
        wcse_armed_dir := 0

// Actionable signals (passed all filters OR volume recovered)
buy_signal = (bsignal and not is_filtered) or deferred_buy
sell_signal = (ssignal and not is_filtered) or deferred_sell

// ── WCSE Pattern Detection (unconditional for series consistency) ──
_engulf_long = detect_wcse_engulf_long(i_wcse_c1_close, i_wcse_c1_body, i_wcse_c2_body)
_engulf_short = detect_wcse_engulf_short(i_wcse_c1_close, i_wcse_c1_body, i_wcse_c2_body)
_engulf_long_3 = detect_wcse_engulf_long_3(i_wcse_c1_close, i_wcse_c1_body, i_wcse_c2_body)
_engulf_short_3 = detect_wcse_engulf_short_3(i_wcse_c1_close, i_wcse_c1_body, i_wcse_c2_body)
_wick_cross_long = detect_wcse_wick_cross_long(i_wcse_wick_cross)
_wick_cross_short = detect_wcse_wick_cross_short(i_wcse_wick_cross)

// ── WCSE Volume Check Helpers ──
// Pattern A (2-candle): check [bar[2], bar[1], bar[0]]
wcse_vol_ok_2(vt) =>
    not use_vol_filter or vol_ratio[2] >= vt or vol_ratio[1] >= vt or vol_ratio >= vt

// Pattern B (3-candle): check [bar[3], bar[2], bar[1], bar[0]]
wcse_vol_ok_3(vt) =>
    not use_vol_filter or vol_ratio[3] >= vt or vol_ratio[2] >= vt or vol_ratio[1] >= vt or vol_ratio >= vt

// Pattern C (1-candle): check [bar[1], bar[0]]
wcse_vol_ok_1(vt) =>
    not use_vol_filter or vol_ratio[1] >= vt or vol_ratio >= vt

// ═══════════════════════════════════════════════════════════════════════════════
// POSITION MANAGEMENT
// ═══════════════════════════════════════════════════════════════════════════════
var float entry_price = na
var float sl_price = na
var float original_sl = na
var float tp_price = na
var int position_dir = 0  // 1=long, -1=short, 0=flat

// ── Signal Swing Close ──
// Any trend change closes opposite position IMMEDIATELY, regardless of filters.
// Vol filter / WCSE / quiet hours only gate NEW entries, never block exits.
if bsignal and strategy.position_size < 0
    strategy.close("Short", comment="Swing Close")
    entry_price := na
    sl_price := na
    original_sl := na
    tp_price := na
    position_dir := 0
    filtered_exit_countdown := 0
    filtered_exit_dir := 0
if ssignal and strategy.position_size > 0
    strategy.close("Long", comment="Swing Close")
    entry_price := na
    sl_price := na
    original_sl := na
    tp_price := na
    position_dir := 0
    filtered_exit_countdown := 0
    filtered_exit_dir := 0

// Filtered exit: close opposite position after countdown
if filtered_exit_now
    if filtered_exit_dir == 1 and strategy.position_size < 0
        strategy.close("Short", comment="Filtered Exit")
        entry_price := na
        sl_price := na
        original_sl := na
        tp_price := na
        position_dir := 0
    if filtered_exit_dir == -1 and strategy.position_size > 0
        strategy.close("Long", comment="Filtered Exit")
        entry_price := na
        sl_price := na
        original_sl := na
        tp_price := na
        position_dir := 0
    filtered_exit_dir := 0

// Track entries this bar to prevent "Reset on flat" from wiping position vars
// (with process_orders_on_close=true, strategy.position_size is still 0 on entry bar)
entered_this_bar = false

// Snapshot entry source BEFORE entries modify it (for trade close TP tracking)
int closing_entry_source = wcse_entry_source

// ── WCSE Close-Price Entry vars ──
wcse_buy_entry = false
wcse_sell_entry = false
wcse_pattern_name = ""

if buy_signal and strategy.position_size <= 0 and i_enable_signal
    // Enter LONG from flat or reverse from SHORT
    // Skip if already LONG (after filtered SELL → position continues with trailing SL)
    entered_this_bar := true
    wcse_entry_source := 0
    wcse_is_wx_entry := false
    entry_price := close + pips_to_price(i_spread_pips)
    sl_price := Trailingsl - pips_to_price(i_sl_buffer)
    original_sl := sl_price
    sl_dist = entry_price - sl_price

    if i_tp_type == "Risk Ratio"
        tp_price := entry_price + (sl_dist * i_tp_ratio)
    else if i_tp_type == "Fixed Pips"
        tp_price := entry_price + pips_to_price(i_tp_pips)
    else
        tp_price := na

    float qty = i_units
    if i_sizing_mode == "Compound Risk %" and sl_dist > 0
        risk_amount = strategy.equity * i_risk_percent / 100
        qty := math.floor(risk_amount / sl_dist)
        qty := math.min(qty, i_max_position)
        qty := math.max(qty, 1)

    position_dir := 1
    strategy.entry("Long", strategy.long, qty=qty)

if sell_signal and strategy.position_size >= 0 and i_enable_signal
    // Enter SHORT from flat or reverse from LONG
    // Skip if already SHORT (after filtered BUY → position continues with trailing SL)
    entered_this_bar := true
    wcse_entry_source := 0
    wcse_is_wx_entry := false
    entry_price := close - pips_to_price(i_spread_pips)
    sl_price := Trailingsl + pips_to_price(i_sl_buffer)
    original_sl := sl_price
    sl_dist = sl_price - entry_price

    if i_tp_type == "Risk Ratio"
        tp_price := entry_price - (sl_dist * i_tp_ratio)
    else if i_tp_type == "Fixed Pips"
        tp_price := entry_price - pips_to_price(i_tp_pips)
    else
        tp_price := na

    float qty = i_units
    if i_sizing_mode == "Compound Risk %" and sl_dist > 0
        risk_amount = strategy.equity * i_risk_percent / 100
        qty := math.floor(risk_amount / sl_dist)
        qty := math.min(qty, i_max_position)
        qty := math.max(qty, 1)

    position_dir := -1
    strategy.entry("Short", strategy.short, qty=qty)

// ── WCSE Close-Price Entry ──
if i_wcse_enabled and wcse_armed_dir != 0 and strategy.position_size == 0 and not entered_this_bar
    can_enter = i_wcse_entry_times == 0 or wcse_tp_exits < i_wcse_entry_times
    if can_enter and not is_quiet
        wcse_matched = false
        wcse_dir = wcse_armed_dir
        wcse_vol_pass = false
        wcse_is_wx = false

        // Priority: A (2-candle engulf) > B (3-candle engulf) > C (wick cross)
        if not wcse_matched and wcse_dir == 1 and _engulf_long
            wcse_matched := true
            wcse_vol_pass := wcse_vol_ok_2(vol_threshold)
            wcse_pattern_name := "E2↑"
        if not wcse_matched and wcse_dir == -1 and _engulf_short
            wcse_matched := true
            wcse_vol_pass := wcse_vol_ok_2(vol_threshold)
            wcse_pattern_name := "E2↓"
        if not wcse_matched and wcse_dir == 1 and _engulf_long_3
            wcse_matched := true
            wcse_vol_pass := wcse_vol_ok_3(vol_threshold)
            wcse_pattern_name := "E3↑"
        if not wcse_matched and wcse_dir == -1 and _engulf_short_3
            wcse_matched := true
            wcse_vol_pass := wcse_vol_ok_3(vol_threshold)
            wcse_pattern_name := "E3↓"
        if not wcse_matched and wcse_dir == 1 and _wick_cross_long
            wcse_matched := true
            wcse_vol_pass := wcse_vol_ok_1(vol_threshold)
            wcse_pattern_name := "WX↑"
            wcse_is_wx := true
        if not wcse_matched and wcse_dir == -1 and _wick_cross_short
            wcse_matched := true
            wcse_vol_pass := wcse_vol_ok_1(vol_threshold)
            wcse_pattern_name := "WX↓"
            wcse_is_wx := true

        if wcse_matched and wcse_vol_pass
            float wcse_sl_buf = pips_to_price(i_wcse_sl_buffer)
            if wcse_dir == 1
                entry_price := close + pips_to_price(i_spread_pips)
                sl_price := wcse_is_wx ? TUp - pips_to_price(i_wcse_wx_sl_buffer) : TUp - wcse_sl_buf
                original_sl := sl_price
                sl_dist = entry_price - sl_price
                if sl_dist > 0
                    if i_tp_type == "Risk Ratio"
                        tp_price := entry_price + (sl_dist * i_wcse_tp_rr)
                    else if i_tp_type == "Fixed Pips"
                        tp_price := entry_price + pips_to_price(i_tp_pips)
                    else
                        tp_price := na
                    float qty = i_units
                    if i_sizing_mode == "Compound Risk %" and sl_dist > 0
                        risk_amount = strategy.equity * i_risk_percent / 100
                        qty := math.floor(risk_amount / sl_dist)
                        qty := math.min(qty, i_max_position)
                        qty := math.max(qty, 1)
                    position_dir := 1
                    entered_this_bar := true
                    wcse_entry_source := 1
                    wcse_entry_count := wcse_entry_count + 1
                    wcse_buy_entry := true
                    if wcse_is_wx
                        wcse_is_wx_entry := true
                        wcse_wx_entry_bar := bar_index
                    strategy.entry("Long", strategy.long, qty=qty)
                else
                    wcse_skip_count := wcse_skip_count + 1
            else
                entry_price := close - pips_to_price(i_spread_pips)
                sl_price := wcse_is_wx ? TDown + pips_to_price(i_wcse_wx_sl_buffer) : TDown + wcse_sl_buf
                original_sl := sl_price
                sl_dist = sl_price - entry_price
                if sl_dist > 0
                    if i_tp_type == "Risk Ratio"
                        tp_price := entry_price - (sl_dist * i_wcse_tp_rr)
                    else if i_tp_type == "Fixed Pips"
                        tp_price := entry_price - pips_to_price(i_tp_pips)
                    else
                        tp_price := na
                    float qty = i_units
                    if i_sizing_mode == "Compound Risk %" and sl_dist > 0
                        risk_amount = strategy.equity * i_risk_percent / 100
                        qty := math.floor(risk_amount / sl_dist)
                        qty := math.min(qty, i_max_position)
                        qty := math.max(qty, 1)
                    position_dir := -1
                    entered_this_bar := true
                    wcse_entry_source := 1
                    wcse_entry_count := wcse_entry_count + 1
                    wcse_sell_entry := true
                    if wcse_is_wx
                        wcse_is_wx_entry := true
                        wcse_wx_entry_bar := bar_index
                    strategy.entry("Short", strategy.short, qty=qty)
                else
                    wcse_skip_count := wcse_skip_count + 1

        if wcse_matched and not wcse_vol_pass
            wcse_skip_count := wcse_skip_count + 1

// ═══════════════════════════════════════════════════════════════════════════════
// SUPERTREND TRAILING STOP
// ═══════════════════════════════════════════════════════════════════════════════
// Trail SL with SuperTrend: use TUp for longs, TDown for shorts
// CRITICAL: use TUp/TDown directly, NOT Trailingsl (which flips with trend)
// Each entry type uses its own buffer and trailing rules
if strategy.position_size != 0 and not na(original_sl)
    // --- Signal entries: trail with i_sl_buffer ---
    if wcse_entry_source != 1
        if position_dir == 1 and not na(TUp)
            trailing_sl = TUp - pips_to_price(i_sl_buffer)
            if trailing_sl > original_sl and trailing_sl > sl_price
                sl_price := trailing_sl
        else if position_dir == -1 and not na(TDown)
            trailing_sl = TDown + pips_to_price(i_sl_buffer)
            if trailing_sl < original_sl and trailing_sl < sl_price
                sl_price := trailing_sl

    // --- E2/E3 WCSE entries: trail with i_wcse_sl_buffer ---
    else if not wcse_is_wx_entry
        if position_dir == 1 and not na(TUp)
            trailing_sl = TUp - pips_to_price(i_wcse_sl_buffer)
            if trailing_sl > original_sl and trailing_sl > sl_price
                sl_price := trailing_sl
        else if position_dir == -1 and not na(TDown)
            trailing_sl = TDown + pips_to_price(i_wcse_sl_buffer)
            if trailing_sl < original_sl and trailing_sl < sl_price
                sl_price := trailing_sl

    // --- WX entries: trail with i_wcse_wx_trail_buffer after N bars ---
    else if bar_index - wcse_wx_entry_bar >= i_wcse_wx_trail_after
        if position_dir == 1 and not na(TUp)
            trailing_sl = TUp - pips_to_price(i_wcse_wx_trail_buffer)
            if trailing_sl > sl_price
                sl_price := trailing_sl
        else if position_dir == -1 and not na(TDown)
            trailing_sl = TDown + pips_to_price(i_wcse_wx_trail_buffer)
            if trailing_sl < sl_price
                sl_price := trailing_sl

// ═══════════════════════════════════════════════════════════════════════════════
// SL/TP EXIT ORDERS
// ═══════════════════════════════════════════════════════════════════════════════
if strategy.position_size > 0 and not na(sl_price)
    if na(tp_price)
        strategy.exit("Long Exit", "Long", stop=sl_price)
    else
        strategy.exit("Long Exit", "Long", stop=sl_price, limit=tp_price)

if strategy.position_size < 0 and not na(sl_price)
    if na(tp_price)
        strategy.exit("Short Exit", "Short", stop=sl_price)
    else
        strategy.exit("Short Exit", "Short", stop=sl_price, limit=tp_price)

// Reset on flat — but NOT on entry bars (with process_orders_on_close=true,
// strategy.position_size is still 0 during script execution on the entry bar)
if strategy.position_size == 0 and position_dir != 0 and not entered_this_bar
    entry_price := na
    sl_price := na
    original_sl := na
    tp_price := na
    position_dir := 0
    wcse_is_wx_entry := false

// ═══════════════════════════════════════════════════════════════════════════════
// P&L LABELS ON TRADE CLOSE
// ═══════════════════════════════════════════════════════════════════════════════
// Use [1] comparison — more reliable than var counter with process_orders_on_close
if strategy.closedtrades > nz(strategy.closedtrades[1])
    trade_idx = strategy.closedtrades - 1
    // Manual P&L calc — strategy.closedtrades.profit() has forex conversion error
    trade_size = strategy.closedtrades.size(trade_idx)
    entry_p = strategy.closedtrades.entry_price(trade_idx)
    exit_p = strategy.closedtrades.exit_price(trade_idx)
    was_short = trade_size < 0
    // Adjust TV entry by spread (TV fills at close, real entry includes spread cost)
    entry_p := was_short ? entry_p - pips_to_price(i_spread_pips) : entry_p + pips_to_price(i_spread_pips)
    pnl = (exit_p - entry_p) * trade_size
    pnl_prefix = closing_entry_source == 1 ? "W:" : "S:"
    pnl_text = pnl >= 0 ? pnl_prefix + "$" + str.tostring(pnl, "#.##") : pnl_prefix + "-$" + str.tostring(math.abs(pnl), "#.##")
    pnl_color = pnl >= 0 ? color.green : color.red
    // WCSE TP tracking: use snapshot from BEFORE entries modified wcse_entry_source
    if closing_entry_source == 1 and pnl > 0
        wcse_tp_exits := wcse_tp_exits + 1
    // Only reset entry source if we didn't just open a new position this bar
    // (WCSE re-entry on the same bar as previous trade close is common after TP hits)
    if not entered_this_bar
        wcse_entry_source := 0
    // SHORT exit → P&L above, LONG exit → P&L below
    label.new(bar_index, na, pnl_text,
         style=label.style_none,
         textcolor=pnl_color, size=size.small,
         yloc=was_short ? yloc.abovebar : yloc.belowbar)

// Unrealized P&L for open position on last bar
var label open_pnl_label = na
if barstate.islast and strategy.opentrades > 0
    open_size = strategy.opentrades.size(0)
    open_entry = strategy.opentrades.entry_price(0)
    open_pnl = (close - open_entry) * open_size
    open_text = (open_pnl >= 0 ? "$" + str.tostring(open_pnl, "#.##") : "-$" + str.tostring(math.abs(open_pnl), "#.##")) + "*"
    open_color = open_pnl >= 0 ? color.green : color.red
    open_is_short = open_size < 0
    if not na(open_pnl_label)
        label.delete(open_pnl_label)
    open_pnl_label := label.new(bar_index, na, open_text,
         style=label.style_none,
         textcolor=open_color, size=size.small,
         yloc=open_is_short ? yloc.abovebar : yloc.belowbar)

// ═══════════════════════════════════════════════════════════════════════════════
// VISUAL: BACKGROUND COLORS
// ═══════════════════════════════════════════════════════════════════════════════
// Quiet hours: light yellow background (continuous zone)
bgcolor(is_quiet and use_quiet ? color.new(color.yellow, 88) : na, title="Quiet Hours Zone")

// Volume filtered signal: light gray background (single bar flash)
bgcolor(is_vol_filtered and show_vol_filter ? color.new(color.gray, 80) : na, title="Vol Filtered Signal")

// WCSE armed: subtle tint shows when WCSE is actively scanning for patterns
// bgcolor(i_wcse_enabled and wcse_armed_dir == 1 ? color.new(color.aqua, 93) : i_wcse_enabled and wcse_armed_dir == -1 ? color.new(color.fuchsia, 93) : na, title="WCSE Armed")

// ═══════════════════════════════════════════════════════════════════════════════
// VISUAL: SIGNAL LABELS
// ═══════════════════════════════════════════════════════════════════════════════
// Actionable signals: green BUY / red SELL
plotshape(buy_signal and showlabel ? Trailingsl : na, title="Buy", text="Buy",
     location=location.absolute, style=shape.labelup, size=size.tiny,
     color=color.lime, textcolor=color.black, display=display.pane)
plotshape(sell_signal and showlabel ? Trailingsl : na, title="Sell", text="Sell",
     location=location.absolute, style=shape.labeldown, size=size.tiny,
     color=color.red, textcolor=color.white, display=display.pane)

// Filtered signals: gray xB/xS with filter reason
plotshape(bsignal and is_qh_filtered and show_vol_filter ? Trailingsl : na, title="QH Filtered Buy", text="xB\nQH",
     location=location.absolute, style=shape.labelup, size=size.tiny,
     color=color.new(color.yellow, 30), textcolor=color.black, display=display.pane)
plotshape(ssignal and is_qh_filtered and show_vol_filter ? Trailingsl : na, title="QH Filtered Sell", text="xS\nQH",
     location=location.absolute, style=shape.labeldown, size=size.tiny,
     color=color.new(color.yellow, 30), textcolor=color.black, display=display.pane)
// Vol filtered (still blocked — no recovery yet or recovery disabled)
plotshape(bsignal and is_vol_filtered and not deferred_buy and show_vol_filter ? Trailingsl : na, title="Vol Filtered Buy", text="xB\nVol",
     location=location.absolute, style=shape.labelup, size=size.tiny,
     color=color.new(color.gray, 30), textcolor=color.white, display=display.pane)
plotshape(ssignal and is_vol_filtered and not deferred_sell and show_vol_filter ? Trailingsl : na, title="Vol Filtered Sell", text="xS\nVol",
     location=location.absolute, style=shape.labeldown, size=size.tiny,
     color=color.new(color.gray, 30), textcolor=color.white, display=display.pane)
// Volume recovered (deferred entry executed)
plotshape(deferred_buy and showlabel ? Trailingsl : na, title="Vol Recovery Buy", text="Buy\nVR",
     location=location.absolute, style=shape.labelup, size=size.tiny,
     color=color.new(color.lime, 30), textcolor=color.black, display=display.pane)
plotshape(deferred_sell and showlabel ? Trailingsl : na, title="Vol Recovery Sell", text="Sell\nVR",
     location=location.absolute, style=shape.labeldown, size=size.tiny,
     color=color.new(color.red, 30), textcolor=color.white, display=display.pane)

// WCSE close-price entry with pattern name + EP/SL/TP info
if wcse_buy_entry and showlabel
    wcse_info = wcse_pattern_name + "\nEP:" + str.tostring(entry_price, "#.#####") + "\nSL:" + str.tostring(sl_price, "#.#####") + "\nTP:" + str.tostring(tp_price, "#.#####")
    label.new(bar_index, TUp, wcse_info,
         style=label.style_label_up, size=size.small,
         color=color.aqua, textcolor=color.black)
    label.new(bar_index, tp_price, "TP " + str.tostring(tp_price, "#.#####"),
         style=label.style_label_left, size=size.tiny,
         color=color.new(color.green, 30), textcolor=color.white)
if wcse_sell_entry and showlabel
    wcse_info = wcse_pattern_name + "\nEP:" + str.tostring(entry_price, "#.#####") + "\nSL:" + str.tostring(sl_price, "#.#####") + "\nTP:" + str.tostring(tp_price, "#.#####")
    label.new(bar_index, TDown, wcse_info,
         style=label.style_label_down, size=size.small,
         color=color.fuchsia, textcolor=color.white)
    label.new(bar_index, tp_price, "TP " + str.tostring(tp_price, "#.#####"),
         style=label.style_label_left, size=size.tiny,
         color=color.new(color.red, 30), textcolor=color.white)

// Filtered exit (delayed close after countdown)
plotshape(filtered_exit_now and filtered_exit_dir == 1 and show_vol_filter, title="Filtered Exit Short", text="FX",
     location=location.abovebar, style=shape.xcross, size=size.tiny,
     color=color.orange, textcolor=color.orange, display=display.pane)
plotshape(filtered_exit_now and filtered_exit_dir == -1 and show_vol_filter, title="Filtered Exit Long", text="FX",
     location=location.belowbar, style=shape.xcross, size=size.tiny,
     color=color.orange, textcolor=color.orange, display=display.pane)

// SL/TP levels
plot(plot_sl_tp and strategy.position_size != 0 ? sl_price : na, "Stop Loss", color=color.red, style=plot.style_linebr, linewidth=2, display=display.pane)
plot(plot_sl_tp and strategy.position_size != 0 ? tp_price : na, "Take Profit", color=color.green, style=plot.style_linebr, linewidth=2, display=display.pane)
plot(plot_sl_tp and strategy.position_size != 0 ? entry_price : na, "Entry Price", color=color.blue, style=plot.style_linebr, linewidth=1, display=display.pane)

// ═══════════════════════════════════════════════════════════════════════════════
// STATISTICS TABLE
// ═══════════════════════════════════════════════════════════════════════════════
var table stats_table = table.new(position.top_right, 2, 32, bgcolor=color.new(color.white, 80), border_width=1)

// Track filter counts
var int total_signals = 0
var int vol_filtered_count = 0
var int vol_recovered_count = 0
var int filtered_exit_count = 0
var int qh_filtered_count = 0
var int traded_count = 0

if bsignal or ssignal
    total_signals := total_signals + 1
if is_vol_filtered
    vol_filtered_count := vol_filtered_count + 1
if deferred_buy or deferred_sell
    vol_recovered_count := vol_recovered_count + 1
if filtered_exit_now
    filtered_exit_count := filtered_exit_count + 1
if is_qh_filtered
    qh_filtered_count := qh_filtered_count + 1
if buy_signal or sell_signal
    traded_count := traded_count + 1

if show_stats and barstate.islast
    row = 0

    // Title
    table.cell(stats_table, 0, row, "PPST Vol Filter", text_color=color.black, text_size=size.normal)
    table.cell(stats_table, 1, row, "Backtest", text_color=color.black, text_size=size.normal)
    row := row + 1

    table.cell(stats_table, 0, row, "─────────", text_color=color.gray, text_size=size.small)
    table.cell(stats_table, 1, row, "─────────", text_color=color.gray, text_size=size.small)
    row := row + 1

    // Config
    table.cell(stats_table, 0, row, "PP SuperTrend", text_color=color.black, text_size=size.small)
    table.cell(stats_table, 1, row, str.tostring(prd) + ", " + str.tostring(Factor) + ", " + str.tostring(Pd), text_color=color.black, text_size=size.small)
    row := row + 1

    table.cell(stats_table, 0, row, "Vol Filter", text_color=color.black, text_size=size.small)
    vf_info = use_vol_filter ? "VF=" + str.tostring(vol_threshold, "#.#") + " SMA" + str.tostring(vol_sma_period) + (vol_recovery_bars > 0 ? " VR:" + str.tostring(vol_recovery_bars) : "") : "OFF"
    table.cell(stats_table, 1, row, vf_info, text_color=use_vol_filter ? color.blue : color.gray, text_size=size.small)
    row := row + 1

    table.cell(stats_table, 0, row, "Quiet Hours", text_color=color.black, text_size=size.small)
    qh_info = use_quiet ? str.tostring(quiet_start_hour, "00") + ":" + str.tostring(quiet_start_min, "00") + "-" + str.tostring(quiet_end_hour, "00") + ":" + str.tostring(quiet_end_min, "00") : "OFF"
    table.cell(stats_table, 1, row, qh_info, text_color=use_quiet ? color.blue : color.gray, text_size=size.small)
    row := row + 1

    table.cell(stats_table, 0, row, "Sizing", text_color=color.black, text_size=size.small)
    sizing_info = i_sizing_mode == "Compound Risk %" ? str.tostring(i_risk_percent) + "% risk" : str.tostring(i_units) + " units"
    table.cell(stats_table, 1, row, sizing_info, text_color=color.black, text_size=size.small)
    row := row + 1

    table.cell(stats_table, 0, row, "SL Buffer", text_color=color.black, text_size=size.small)
    table.cell(stats_table, 1, row, str.tostring(i_sl_buffer) + " pips", text_color=color.black, text_size=size.small)
    row := row + 1

    table.cell(stats_table, 0, row, "TP Type", text_color=color.black, text_size=size.small)
    tp_info = i_tp_type == "Risk Ratio" ? str.tostring(i_tp_ratio) + " R:R" : i_tp_type == "Fixed Pips" ? str.tostring(i_tp_pips) + "p" : "None (swing)"
    table.cell(stats_table, 1, row, tp_info, text_color=color.black, text_size=size.small)
    row := row + 1

    table.cell(stats_table, 0, row, "Spread", text_color=color.black, text_size=size.small)
    table.cell(stats_table, 1, row, str.tostring(i_spread_pips) + " pips", text_color=color.black, text_size=size.small)
    row := row + 1

    // Divider
    table.cell(stats_table, 0, row, "─────────", text_color=color.gray, text_size=size.small)
    table.cell(stats_table, 1, row, "─────────", text_color=color.gray, text_size=size.small)
    row := row + 1

    // Signal stats
    table.cell(stats_table, 0, row, "Total Signals", text_color=color.black, text_size=size.small)
    table.cell(stats_table, 1, row, str.tostring(total_signals), text_color=color.black, text_size=size.small)
    row := row + 1

    table.cell(stats_table, 0, row, "Vol Filtered", text_color=color.black, text_size=size.small)
    table.cell(stats_table, 1, row, str.tostring(vol_filtered_count), text_color=vol_filtered_count > 0 ? color.orange : color.gray, text_size=size.small)
    row := row + 1

    table.cell(stats_table, 0, row, "Vol Recovered", text_color=color.black, text_size=size.small)
    table.cell(stats_table, 1, row, str.tostring(vol_recovered_count), text_color=vol_recovered_count > 0 ? color.green : color.gray, text_size=size.small)
    row := row + 1

    table.cell(stats_table, 0, row, "Filtered Exits", text_color=color.black, text_size=size.small)
    fe_info = filtered_exit_bars > 0 ? str.tostring(filtered_exit_count) + " (" + str.tostring(filtered_exit_bars) + "bar)" : "OFF"
    table.cell(stats_table, 1, row, fe_info, text_color=filtered_exit_count > 0 ? color.orange : color.gray, text_size=size.small)
    row := row + 1

    table.cell(stats_table, 0, row, "QH Filtered", text_color=color.black, text_size=size.small)
    table.cell(stats_table, 1, row, str.tostring(qh_filtered_count), text_color=qh_filtered_count > 0 ? color.orange : color.gray, text_size=size.small)
    row := row + 1

    table.cell(stats_table, 0, row, "Traded", text_color=color.black, text_size=size.small)
    filter_pct = total_signals > 0 ? (1.0 - traded_count / total_signals) * 100 : 0
    table.cell(stats_table, 1, row, str.tostring(traded_count) + " (" + str.tostring(filter_pct, "#.#") + "% filtered)", text_color=color.blue, text_size=size.small)
    row := row + 1

    // Divider
    table.cell(stats_table, 0, row, "─────────", text_color=color.gray, text_size=size.small)
    table.cell(stats_table, 1, row, "─────────", text_color=color.gray, text_size=size.small)
    row := row + 1

    // Performance from strategy built-ins
    table.cell(stats_table, 0, row, "Closed Trades", text_color=color.black, text_size=size.small)
    table.cell(stats_table, 1, row, str.tostring(strategy.closedtrades), text_color=color.black, text_size=size.small)
    row := row + 1

    win_trades = strategy.wintrades
    total_closed = strategy.closedtrades
    win_rate = total_closed > 0 ? (win_trades / total_closed) * 100 : 0
    table.cell(stats_table, 0, row, "Win Rate", text_color=color.black, text_size=size.small)
    table.cell(stats_table, 1, row, str.tostring(win_rate, "#.#") + "%", text_color=win_rate >= 50 ? color.green : color.red, text_size=size.small)
    row := row + 1

    gross_profit = strategy.grossprofit
    gross_loss = math.abs(strategy.grossloss)
    profit_factor = gross_loss > 0 ? gross_profit / gross_loss : gross_profit > 0 ? 999 : 0
    table.cell(stats_table, 0, row, "Profit Factor", text_color=color.black, text_size=size.small)
    table.cell(stats_table, 1, row, str.tostring(profit_factor, "#.##"), text_color=profit_factor >= 1 ? color.green : color.red, text_size=size.small)
    row := row + 1

    table.cell(stats_table, 0, row, "Net Profit", text_color=color.black, text_size=size.small)
    net_profit = strategy.netprofit
    table.cell(stats_table, 1, row, "$" + str.tostring(net_profit, "#.##"), text_color=net_profit >= 0 ? color.green : color.red, text_size=size.small)
    row := row + 1

    table.cell(stats_table, 0, row, "Max Drawdown", text_color=color.black, text_size=size.small)
    table.cell(stats_table, 1, row, "$" + str.tostring(strategy.max_drawdown, "#.##"), text_color=color.red, text_size=size.small)
    row := row + 1

    // Current vol ratio (for reference)
    table.cell(stats_table, 0, row, "─────────", text_color=color.gray, text_size=size.small)
    table.cell(stats_table, 1, row, "─────────", text_color=color.gray, text_size=size.small)
    row := row + 1

    table.cell(stats_table, 0, row, "Cur Vol Ratio", text_color=color.black, text_size=size.small)
    table.cell(stats_table, 1, row, str.tostring(vol_ratio, "#.##"), text_color=vol_ratio >= vol_threshold ? color.green : color.red, text_size=size.small)
    row := row + 1

    table.cell(stats_table, 0, row, "Position", text_color=color.black, text_size=size.small)
    pos_info = strategy.position_size > 0 ? "LONG" : strategy.position_size < 0 ? "SHORT" : "FLAT"
    table.cell(stats_table, 1, row, pos_info, text_color=strategy.position_size != 0 ? color.blue : color.gray, text_size=size.small)
    row := row + 1

    // WCSE stats
    if i_wcse_enabled
        table.cell(stats_table, 0, row, "─────────", text_color=color.gray, text_size=size.small)
        table.cell(stats_table, 1, row, "─────────", text_color=color.gray, text_size=size.small)
        row := row + 1

        table.cell(stats_table, 0, row, "WCSE Mode", text_color=color.black, text_size=size.small)
        wcse_mode = not i_enable_signal ? "WCSE Only" : "Signal" + (i_wcse_enabled ? " + WCSE" : "")
        table.cell(stats_table, 1, row, wcse_mode, text_color=color.aqua, text_size=size.small)
        row := row + 1

        table.cell(stats_table, 0, row, "WCSE Entries", text_color=color.black, text_size=size.small)
        table.cell(stats_table, 1, row, str.tostring(wcse_entry_count) + (wcse_skip_count > 0 ? " (" + str.tostring(wcse_skip_count) + " skip)" : ""), text_color=wcse_entry_count > 0 ? color.aqua : color.gray, text_size=size.small)
        row := row + 1

        table.cell(stats_table, 0, row, "WCSE TP Exits", text_color=color.black, text_size=size.small)
        table.cell(stats_table, 1, row, str.tostring(wcse_tp_exits) + "/" + str.tostring(i_wcse_entry_times == 0 ? 0 : i_wcse_entry_times), text_color=color.aqua, text_size=size.small)
        row := row + 1

        table.cell(stats_table, 0, row, "WCSE Settings", text_color=color.black, text_size=size.small)
        wcse_info = "RR:" + str.tostring(i_wcse_tp_rr) + " ET:" + str.tostring(i_wcse_entry_times) + " C:" + str.tostring(i_wcse_c1_close) + " WX:" + str.tostring(i_wcse_wick_cross)
        table.cell(stats_table, 1, row, wcse_info, text_color=color.gray, text_size=size.small)
