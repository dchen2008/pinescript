// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © LonesomeTheBlue

//@version=4
strategy("PPST Signal Swing (No Circle)", overlay=true,
         default_qty_type=strategy.fixed,
         default_qty_value=10000,
         initial_capital=10000,
         currency=currency.USD,
         commission_type=strategy.commission.percent,
         commission_value=0.01,
         process_orders_on_close=true)
prd = input(defval = 2, title="Pivot Point Period", minval = 1, maxval = 50)
Factor=input(defval = 4.5, title = "ATR Factor", minval = 1, step = 0.1)
Pd=input(defval = 10, title = "ATR Period", minval=1)
minrateu = input(defval = 1.0, title="Min profit Rate if Center Line Used", minval = 0)
usecenter = input(defval = false, title="Use Center Line to Close Entry for 50%")

// === BACKTEST DATE RANGE ===
useDateFilter = input(defval = true, title="Use Date Filter")
startDate = input(defval = timestamp("01 Feb 2025 00:00"), title="Start Date", type=input.time)
endDate = input(defval = timestamp("07 Feb 2026 23:59"), title="End Date", type=input.time)
inDateRange = useDateFilter ? (time >= startDate and time <= endDate) : true

// === POSITION SIZING ===
useRiskBasedSizing = input(defval = true, title="Use Risk-Based Position Sizing")
riskPercent = input(defval = 1.5, title="Risk Per Trade (% of Balance)", minval=0.1, step=0.1, tooltip="Dynamic risk: 1.5% of $10,000 = $150 risk per trade. Scales with equity.")
maxPositionSize = input(defval = 2000000, title="Max Position Size (units)", minval=1000, tooltip="Cap for compound sizing. 2M ≈ $40K equity at 50:1 OANDA leverage.")

// === SPREAD COST ===
spreadPips = input(defval = 1.5, title="Spread Cost (pips)", minval=0, step=0.1)
// Convert pips to price (1 pip = 10 points for 5-decimal forex)
pipValue = syminfo.mintick * 10
spreadPrice = spreadPips * pipValue

// === TAKE PROFIT OPTIONS ===
useRRTP = input(defval = true, title="Use RR-Based Take Profit")
rrRatio = input(defval = 2.0, title="Risk-Reward Ratio for TP", minval=0.1, step=0.1)
showTPLine = input(defval = true, title="Show TP Level Line")
showpivot = input(defval = false, title="Show Pivot Points")
showcl = input(defval = false, title="Show PP Center Line")
onlylong = input(defval = false, title="Enter Only Long Position")
float minrate = minrateu / 100

// === TIME FILTERS ===
// Daily quiet window (no trading)
useQuietWindow = input(defval = false, title="Use Daily Quiet Window")
quietStartHour = input(defval = 13, title="Quiet Window Start Hour (0-23)", minval=0, maxval=23)
quietStartMin = input(defval = 30, title="Quiet Window Start Minute (0-59)", minval=0, maxval=59)
quietEndHour = input(defval = 16, title="Quiet Window End Hour (0-23)", minval=0, maxval=23)
quietEndMin = input(defval = 30, title="Quiet Window End Minute (0-59)", minval=0, maxval=59)

// Market open window (Sunday 2pm to Friday 2pm PT)
useMarketWindow = input(defval = false, title="Use Market Open Window")
marketOpenDay = input(defval = 1, title="Market Open Day (1=Sun, 7=Sat)", minval=1, maxval=7)
marketOpenHour = input(defval = 14, title="Market Open Hour", minval=0, maxval=23)
marketCloseDay = input(defval = 6, title="Market Close Day (1=Sun, 7=Sat)", minval=1, maxval=7)
marketCloseHour = input(defval = 14, title="Market Close Hour", minval=0, maxval=23)

// Time calculations (using PT timezone via exchange timezone or chart)
currentHour = hour(time, "America/Los_Angeles")
currentMin = minute(time, "America/Los_Angeles")
currentDay = dayofweek(time, "America/Los_Angeles")

// Convert to minutes since midnight for precise quiet window comparison
currentTimeInMin = currentHour * 60 + currentMin
quietStartInMin = quietStartHour * 60 + quietStartMin
quietEndInMin = quietEndHour * 60 + quietEndMin

// Check if NOT in quiet window (quiet window = no trading)
// Uses minute precision for 13:30-16:30 style windows
notInQuietWindow = (not useQuietWindow) or
     (quietStartInMin < quietEndInMin ?
      (currentTimeInMin < quietStartInMin or currentTimeInMin >= quietEndInMin) :
      (currentTimeInMin >= quietEndInMin and currentTimeInMin < quietStartInMin))

// Check if market is open (Sunday 2pm PT to Friday 2pm PT)
// dayofweek: 1=Sunday, 2=Monday, ... 6=Friday, 7=Saturday
isMarketOpen() =>
    if not useMarketWindow
        true
    else
        // After Sunday open hour
        afterSundayOpen = (currentDay == marketOpenDay and currentHour >= marketOpenHour) or currentDay > marketOpenDay
        // Before Friday close hour
        beforeFridayClose = (currentDay == marketCloseDay and currentHour < marketCloseHour) or currentDay < marketCloseDay
        // Not Saturday
        notWeekend = currentDay != 7
        afterSundayOpen and beforeFridayClose and notWeekend

// Combined filter: all conditions must be true to trade
canTrade = notInQuietWindow and isMarketOpen() and inDateRange

// Visual indicator for no-trade periods
showNoTradeZones = input(defval = false, title="Show No-Trade Zones (Background)")
bgcolor(showNoTradeZones and not canTrade ? color.new(color.gray, 90) : na, title="No Trade Zone")

// === ENTRY DISTANCE FILTER ===
maxEntryDist = input(defval = 20.0, title="Max Entry Distance from SuperTrend (Pips)", minval=1, step=0.5)

// === BREAK-EVEN ===
useBE = input(defval = true, title="Enable Break-Even")
beTriggerPips = input(defval = 10.0, title="BE Trigger (Pips in Profit)", minval=5, step=1.0)
beOffsetPips = input(defval = 1.0, title="BE Offset (Pips)", minval=0, step=0.5)

float ph = na
float pl = na
ph := pivothigh(prd, prd)
pl := pivotlow(prd, prd)

plotshape(ph and showpivot, text="H",  style=shape.labeldown, color=na, textcolor=color.red, location=location.abovebar, offset = -prd)
plotshape(pl and showpivot, text="L",  style=shape.labeldown, color=na, textcolor=color.lime, location=location.belowbar, offset = -prd)

float center = na
center := center[1]
float lastpp = ph ? ph : pl ? pl : na
if lastpp
    if na(center)
        center := lastpp
    else
        center := (center * 2 + lastpp) / 3

Up = center - (Factor * atr(Pd))
Dn = center + (Factor * atr(Pd))

float TUp = na
float TDown = na
Trend = 0
TUp := close[1] > TUp[1] ? max(Up, TUp[1]) : Up
TDown := close[1] < TDown[1] ? min(Dn, TDown[1]) : Dn
Trend := close > TDown[1] ? 1: close < TUp[1]? -1: nz(Trend[1], 1)
Trailingsl = Trend == 1 ? TUp : TDown

linecolor = Trend == 1 and nz(Trend[1]) == 1 ? color.lime : Trend == -1 and nz(Trend[1]) == -1 ? color.red : na
plot(Trailingsl, color = linecolor ,  linewidth = 2, title = "PP SuperTrend")

// === RR-BASED TP TRACKING ===
// Track entry SL level and calculate TP
var float entrySL = na
var float tpLevel = na
var float entryPrice = na
var int posDirection = 0  // 1 = long, -1 = short, 0 = flat
var bool beTriggered = false

// Detect new position entry
newLongEntry = strategy.position_size > 0 and strategy.position_size[1] <= 0
newShortEntry = strategy.position_size < 0 and strategy.position_size[1] >= 0

// Current ATR value for debug labels
currentATR = atr(Pd)
atrRisk = Factor * currentATR

if newLongEntry
    // For LONG: Buy at ASK (mid + spread), SL is below entry, TP is above entry
    entryPrice := strategy.position_avg_price + spreadPrice  // Adjust for spread (buy at ask)
    entrySL := TUp  // SuperTrend lower band as SL
    slDistance = entryPrice - entrySL  // Actual risk distance (includes spread)
    if useRRTP and slDistance > 0
        tpLevel := entryPrice + (slDistance * rrRatio)  // TP based on actual SL distance
    posDirection := 1
    beTriggered := false

if newShortEntry
    // For SHORT: Sell at BID (mid - spread), SL is above entry, TP is below entry
    entryPrice := strategy.position_avg_price - spreadPrice  // Adjust for spread (sell at bid)
    entrySL := TDown  // SuperTrend upper band as SL
    slDistance = entrySL - entryPrice  // Actual risk distance (includes spread)
    if useRRTP and slDistance > 0
        tpLevel := entryPrice - (slDistance * rrRatio)  // TP based on actual SL distance
    posDirection := -1
    beTriggered := false

// Trail the SL with SuperTrend (only moves in favorable direction)
if posDirection == 1 and strategy.position_size > 0
    // LONG: Trail SL up with TUp (never down)
    entrySL := max(entrySL, TUp)
if posDirection == -1 and strategy.position_size < 0
    // SHORT: Trail SL down with TDown (never up)
    entrySL := min(entrySL, TDown)

// Plot TP level and Entry SL for debugging
plot(useRRTP and showTPLine and not na(tpLevel) ? tpLevel : na,
     color=color.new(color.blue, 0), linewidth=2, style=plot.style_linebr, title="TP Level")
plot(useRRTP and showTPLine and not na(entrySL) ? entrySL : na,
     color=color.new(color.orange, 0), linewidth=1, style=plot.style_linebr, title="Entry SL Level")

// Debug label on entry
showDebugLabels = input(defval = false, title="Show TP Debug Labels")
if newLongEntry and showDebugLabels
    label.new(bar_index, high,
              "LONG\nEntry:" + tostring(entryPrice, "#.#####") +
              "\nTP:" + tostring(tpLevel, "#.#####") +
              "\nSL:" + tostring(entrySL, "#.#####") +
              "\nATR:" + tostring(currentATR, "#.#####") +
              "\nRisk$:" + tostring(atrRisk, "#.#####") +
              (useRiskBasedSizing ? "\nSize:" + tostring(abs(strategy.position_size), "#") : ""),
              color=color.green, textcolor=color.white, size=size.small)
if newShortEntry and showDebugLabels
    label.new(bar_index, low,
              "SHORT\nEntry:" + tostring(entryPrice, "#.#####") +
              "\nTP:" + tostring(tpLevel, "#.#####") +
              "\nSL:" + tostring(entrySL, "#.#####") +
              "\nATR:" + tostring(currentATR, "#.#####") +
              "\nRisk$:" + tostring(atrRisk, "#.#####") +
              (useRiskBasedSizing ? "\nSize:" + tostring(abs(strategy.position_size), "#") : ""),
              color=color.red, textcolor=color.white, size=size.small, style=label.style_label_up)

plot(showcl ? center : na, color = showcl ? center < hl2 ? color.blue : color.red : na)

bsignal = Trend == 1 and Trend[1] == -1
ssignal = Trend == -1 and Trend[1] == 1

// === SIGNAL VISUALIZATION ===
showSignals = input(defval = true, title="Show BUY/SELL Signal Labels")

// Plot BUY signal (green label below bar)
plotshape(showSignals and bsignal and canTrade,
          title="Buy Signal", text="BUY", textcolor=color.white,
          style=shape.labelup, location=location.belowbar,
          color=color.green, size=size.small)

// Plot SELL signal (red label above bar)
plotshape(showSignals and ssignal and not onlylong and canTrade,
          title="Sell Signal", text="SELL", textcolor=color.white,
          style=shape.labeldown, location=location.abovebar,
          color=color.red, size=size.small)

// Plot signals blocked by time filter (gray, optional)
showBlockedSignals = input(defval = false, title="Show Blocked Signals (gray)")
plotshape(showBlockedSignals and bsignal and not canTrade,
          title="Blocked Buy", text="BUY", textcolor=color.gray,
          style=shape.labelup, location=location.belowbar,
          color=color.new(color.gray, 50), size=size.tiny)
plotshape(showBlockedSignals and ssignal and not onlylong and not canTrade,
          title="Blocked Sell", text="SELL", textcolor=color.gray,
          style=shape.labeldown, location=location.abovebar,
          color=color.new(color.gray, 50), size=size.tiny)

halfexited = false
halfexited := nz(halfexited[1], false)

// Entry logic - reversal strategy with distance filter
if bsignal and canTrade
    ep = close + spreadPrice  // spread-adjusted entry (ASK)
    sl = TUp  // SuperTrend as SL
    slDist = ep - sl
    distPips = slDist / pipValue

    if slDist > 0 and distPips <= maxEntryDist
        if useRiskBasedSizing
            riskAmt = strategy.equity * riskPercent / 100
            qty = max(1.0, min(maxPositionSize, floor(riskAmt / slDist)))
            strategy.entry("Buy", true, qty=qty, comment="Buy")
        else
            strategy.entry("Buy", true, comment="Buy")
    else
        // Distance filter blocked entry - still close opposite position on trend reversal
        if strategy.position_size < 0
            strategy.close("Sell", comment="Trend Rev")

if ssignal and not onlylong and canTrade
    ep = close - spreadPrice  // spread-adjusted entry (BID)
    sl = TDown  // SuperTrend as SL
    slDist = sl - ep
    distPips = slDist / pipValue

    if slDist > 0 and distPips <= maxEntryDist
        if useRiskBasedSizing
            riskAmt = strategy.equity * riskPercent / 100
            qty = max(1.0, min(maxPositionSize, floor(riskAmt / slDist)))
            strategy.entry("Sell", false, qty=qty, comment="Sell")
        else
            strategy.entry("Sell", false, comment="Sell")
    else
        // Distance filter blocked entry - still close opposite position on trend reversal
        if strategy.position_size > 0
            strategy.close("Buy", comment="Trend Rev")

// Close existing positions when entering quiet window
// Fires on the first bar where quiet window becomes active
enteringQuietWindow = useQuietWindow and not notInQuietWindow and nz(notInQuietWindow[1], true)
if enteringQuietWindow
    if strategy.position_size > 0
        strategy.close("Buy", comment="Quiet Close")
    if strategy.position_size < 0
        strategy.close("Sell", comment="Quiet Close")

// === BREAK-EVEN LOGIC ===
if strategy.position_size != 0 and useBE and not beTriggered and not na(entryPrice)
    profitPips = posDirection == 1 ? (close - entryPrice) / pipValue : (entryPrice - close) / pipValue
    if profitPips >= beTriggerPips
        beTriggered := true
        bePrice = entryPrice + (posDirection * beOffsetPips * pipValue)
        if posDirection == 1
            entrySL := max(nz(entrySL), bePrice)
        else
            entrySL := min(nz(entrySL), bePrice)

// === EXIT ORDERS (combined SL + TP in single call) ===
if not na(entrySL)
    if posDirection == 1
        if useRRTP and not na(tpLevel)
            strategy.exit("Exit Long", "Buy", stop=entrySL, limit=tpLevel)
        else
            strategy.exit("Exit Long", "Buy", stop=entrySL)
    if posDirection == -1
        if useRRTP and not na(tpLevel)
            strategy.exit("Exit Short", "Sell", stop=entrySL, limit=tpLevel)
        else
            strategy.exit("Exit Short", "Sell", stop=entrySL)

// Reset tracking when position closes
if strategy.position_size == 0 and strategy.position_size[1] != 0
    tpLevel := na
    entrySL := na
    entryPrice := na
    posDirection := 0
    beTriggered := false

cpsize = change(strategy.position_size)
if change(strategy.position_size)
    if cpsize > 0 and strategy.position_size > 0 or cpsize< 0 and strategy.position_size < 0
        halfexited := false
    
if strategy.position_size > 0 and center > hl2 and usecenter and not halfexited and close > strategy.position_avg_price * (1 + minrate)
    strategy.close("Buy", qty_percent = 50, comment = "close buy for 50%")
    halfexited := true
if strategy.position_size < 0 and center < hl2 and usecenter and not halfexited and close < strategy.position_avg_price * (1 - minrate)
    strategy.close("Sell", qty_percent = 50, comment = "close sell for 50%")
    halfexited := true

